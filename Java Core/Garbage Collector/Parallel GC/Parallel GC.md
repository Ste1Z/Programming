Назад к: [[Garbage Collector]]

---
### Как работает Parallel GC?
Parallel GC (параллельный сборщик) развивает идеи, заложенные последовательным сборщиком, добавляя в них параллелизм и немного интеллекта. Если на вашем компьютере больше одного процессорного ядра и вы явно не указали, какой сборщик хотите использовать в своей программе, то почти наверняка JVM остановит свой выбор на Parallel GC. Он достаточно простой, но в то же время достаточно функциональный, чтобы удовлетворить потребности большинства приложений.  
Параллельный сборщик включается опцией `-XX:+UseParallelGC`.  
### Принципы работы
При подключении параллельного сборщика используются те же самые подходы к организации кучи, что и в случае с Serial GC — она делится на такие же регионы Eden, Survivor 0, Survivor 1 и Old Gen (знакомый нам под именем Tenured), функционирующие по тому же принципу. Но есть два принципиальных отличия в работе с этими регионами: во-первых, сборкой мусора занимаются несколько потоков параллельно; во-вторых, данный сборщик может самостоятельно подстраиваться под требуемые параметры производительности. Давайте разберемся, как это устроено.  
Для определения количества потоков, которые будут использоваться при сборке мусора, на компьютере с N ядрами процессора, JVM по умолчанию применяет следующую формулу: если N ≤ 8, то количество потоков равно N, иначе для получения количества потоков N домножается на коэффициент, зависящий от других параметров, обычно это 5/8, но на некоторых платформах коэффициент может быть меньше.  
По умолчанию и малая и полная сборка задействуют многопоточность. Малая пользуется ею при переносе объектов в старшее поколение, а полная — при уплотнении данных в старшем поколении.  
Каждый поток сборщика получает свой участок памяти в регионе Old Gen, так называемый _буфер повышения (promotion buffer)_, куда только он может переносить данные, чтобы не мешать другим потокам. Такой подход ускоряет сборку мусора, но имеет и небольшое негативное последствие в виде возможной фрагментации памяти:  
![[Pasted image 20241108183956.png]]
Интеллектуальная составляющая улучшений параллельного сборщика относительно последовательного заключается в том, что у него есть настройки, ориентированные на достижение необходимой вам эффективности сборки мусора. Вы можете указать устраивающие вас параметры производительности — максимальное время сборки и/или пропускную способность — и сборщик будет изо всех сил стараться не превышать заданные пороги. Для этого он будет использовать статистику уже прошедших сборок мусора и исходя из нее планировать параметры дальнейших сборок: варьировать размеры поколений, менять пропорции регионов.  
Например, если при малой сборке JVM не удается укладываться в отведенное вами время, размер младшего поколения может быть уменьшен. Если не удается достигнуть заданной пропускной способности, а с задержкой проблем нет, то размер поколения будет увеличен. И так далее.  
При этом следует иметь в виду, что в статистике игнорируются сборки мусора, запущенные вами вручную.  
Конечно, стопроцентной гарантии достижения желаемых параметров вам никто не даст, но попробовать можно, часто установки нужных опций оказывается достаточно.  
В случае, если вы задали слишком жесткие требования, которые сборщик не может выполнить, он будет ориентироваться на следующие приоритеты (в порядке убывания важности):  
1. Снижение максимальной паузы.
2. Повышение пропускной способности.
3. Минимизация используемой памяти.
При этом Parallel GC оставляет нам возможность самостоятельно корректировать размеры регионов, как и в последовательном сборщике. Но не рекомендуется делать и то и другое одновременно, чтобы не дезориентировать алгоритмы автоматической подстройки. Либо мы выделяем приложению достаточно памяти, указываем желаемые параметры производительности и наблюдаем со стороны, либо сами залезаем в настройки регионов, но тогда лишаемся права требовать от сборщика автоматической подстройки под нужные нам критерии производительности. Ругаться он на нас в случае нарушения данного правила не будет, но и эффективно выполнять свою работу тоже не сможет.  
### Ситуации STW
Как и в случае с последовательным сборщиком, на время операций по очистке памяти все основные потоки приложения останавливаются. Разница только в том, что пауза, как правило, короче за счет выполнения части работ в параллельном режиме.  
### Настройка
Для параллельного сборщика применимы все те же опции, что и для последовательного. Вы можете вручную устанавливать размеры регионов памяти или пропорции между ними. Ниже перечислены те опции, которые добавляются параллельным сборщиком к тому, что мы уже рассматривали выше.  
Вы можете вручную указать количество потоков, которое хотели бы выделить для сборки мусора. Это делается с помощью опции `-XX:ParallelGCThreads=?`. Например, `-XX:ParallelGCThreads=9` ограничит количество потоков девятью. Имейте в виду, что увеличение количества потоков не только сильнее распараллеливает сборку, но и увеличивает фрагментацию региона Tenured, а также добавляет накладные расходы на синхронизацию этих потоков.  
При желании вы можете полностью отключить параллельные работы по уплотнению объектов в старшем поколении опцией `-XX:-UseParallelOldGC`.  
Установка желаемых параметров производительности сборщика выполняется с помощью опций `-XX:MaxGCPauseMillis=?` и `-XX:GCTimeRatio=?`.  
`MaxGCPauseMillis` устанавливает ограничение на максимальное время приостановки программы для сборки мусора. Например, `-XX:MaxGCPauseMillis=400`, укажет JVM, что паузы на сборку мусора желательно не затягивать дольше, чем на 400 миллисекунд. По умолчанию такого ограничения нет. При установке данного параметра следует помнить, что ограничение на время сборки может приводить к необходимости выполнять ее чаще, в результате чего будет страдать общая пропускная способность.  
С помощью опции `GCTimeRatio` вы можете указать желаемый порог пропускной способности (отношения времени работы программы ко времени сборки мусора). Например, при `-XX:GCTimeRatio=49` JVM будет пытаться выполнять сборки таким образом, чтобы они суммарно занимали не больше 2% времени работы программы (отношение времени сборки ко времени работы программы будет 1 / (1 + 49)).  
Опции `-XX:YoungGenerationSizeIncrement=?` и `-XX:TenuredGenerationSizeIncrement=?` устанавливают, на сколько процентов следует при необходимости увеличивать младшее и старшее поколение соотвественно. По умолчанию оба этих параметра равны 20.  
А вот скорость уменьшения размеров поколений регулируется не процентами, а специальным фактором через опцию `-XX:AdaptiveSizeDecrementScaleFactor`. Она указывает, во сколько раз уменьшение должно быть меньше увеличения. Эта опция распространяется на оба поколения. Например, при `-XX:AdaptiveSizeDecrementScaleFactor=2` каждое уменьшение поколения будет в два раза меньше, чем его увеличение (то есть оба поколения будут уменьшаться на 10% при `-XX:GenerationSizeIncrement=20` и `-XX:TenuredGenerationSizeIncrement=20`).  
### Достоинства и недостатки
Бесспорным плюсом данного сборщика на фоне Serial GC является возможность автоматической подстройки под требуемые параметры производительности и меньшие паузы на время cборок. При наличии нескольких процессорных ядер выигрыш в скорости будет практически во всех приложениях.  
Определенная фрагментация памяти, конечно, является минусом, но вряд ли она будет существенной для большинства приложений, так как сборщиком используется относительно небольшое количество потоков.  
В целом, Parallel GC — это простой, понятный и эффективный сборщик, подходящий для большинства приложений. У него нет скрытых накладных расходов, мы всегда можем поменять его настройки и ясно увидеть результат этих изменений.  
Но бывает так, что его оказывается недостаточно и нужно искать что-то более изощренное. О более продвинутых реализациях сборщиков мы поговорим уже в следующей статье.
Источник: [Хабр](https://habr.com/ru/articles/269707/)