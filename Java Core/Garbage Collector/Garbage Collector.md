Назад к: [[Java Core]]

---
## Содержание:

^e46a15

Общая информация
Ключевые моменты
Основные понятия
Как работает
Возможные вопросы

---
## Общая информация:
**Сборщик мусора (Garbage Collector, GC)** в Java — это механизм управления памятью, встроенный в JVM, который автоматически освобождает память, занятую объектами, более не используемыми приложением. Вместо ручного управления памятью (как в C++), Java предоставляет автоматическое управление, позволяя разработчикам избегать ошибок, связанных с утечками памяти.

[[Garbage Collector#^e46a15|К содержанию]]

---
## Ключевые моменты:
- **Автоматическое управление памятью:** GC освобождает память автоматически, что упрощает работу разработчиков.
- **Отслеживание "мертвых" объектов:** GC определяет, какие объекты более не используются (их невозможно достичь из корневых объектов) и могут быть удалены.
- **Алгоритмы для различных потребностей:** В JVM реализовано несколько алгоритмов и стратегий сборки мусора (Serial, Parallel, CMS, G1, ZGC и Shenandoah), каждый из которых оптимизирован для различных сценариев.
- **Многопоточность:** Некоторые GC используют многопоточность для увеличения производительности, что особенно важно для многопроцессорных систем.
- **"Stop-the-World" паузы:** Некоторые алгоритмы приостанавливают выполнение всех потоков приложения для сборки мусора, что может вызывать задержки, особенно в приложениях с требованиями к низкой задержке (low-latency).

[[Garbage Collector#^e46a15|К содержанию]]

---
## Основные понятия:
- **Куча (Heap):** Область памяти, где размещаются все динамически создаваемые объекты. Она делится на различные поколения (молодое, старшее, постоянное) для эффективного управления памятью.
- **Поколения объектов:** В куче объекты разделяются на поколения — молодое, старшее и иногда постоянное:
    - **Молодое поколение (Young Generation):** Сюда попадают новые объекты. Сборка мусора здесь происходит чаще и быстрее, поскольку большинство объектов "умирает" вскоре после создания.
    - **Старшее поколение (Old Generation):** Сюда перемещаются объекты, пережившие несколько циклов сборки мусора в молодом поколении. Сборка мусора в старшем поколении занимает больше времени, но выполняется реже.
    - **Постоянное поколение (Permanent Generation):** Область, где хранятся метаданные классов и методы. В новых версиях JVM (Java 8 и выше) заменено на Metaspace.
	- **GC Roots:** Это "корневые" объекты, от которых начинается анализ достижимости других объектов в памяти. Они включают статические переменные, локальные переменные текущих потоков, объекты JNI и некоторые другие.
	- **Сборка мусора (Garbage Collection):** Процесс, при котором GC ищет объекты, которые более не используются, и освобождает занятую ими память. Существует несколько стратегий GC: копирование (Copying), маркировка и сжатие (Mark-Compact), маркировка и удаление (Mark-Sweep).

[[Garbage Collector#^e46a15|К содержанию]]

---
## Как работает:
Работа сборщика мусора в Java устроена следующим образом:
1. **Выявление "мертвых" объектов:** JVM отслеживает объекты, до которых можно добраться через "корневые" ссылки (GC Roots), такие как локальные переменные, статические поля классов и активные потоки. Все объекты, которые не связаны с GC Roots, считаются "мертвыми" и подлежат удалению.
2. **Разделение кучи на поколения:** Куча делится на молодое и старшее поколения, что позволяет оптимизировать процесс сборки. Молодое поколение, куда попадают новые объекты, собирается чаще, а старшее поколение — реже, так как в нем находятся долгоживущие объекты.
3. **Алгоритмы и подходы к сборке:**
    - **Copying (Копирование):** В молодом поколении обычно используется алгоритм копирования, когда "живые" объекты перемещаются из одной части памяти в другую, оставляя неиспользуемую область для новых объектов.
    - **Mark-and-Sweep (Маркировка и удаление):** В старшем поколении чаще применяется алгоритм "маркировка и удаление" — GC помечает "живые" объекты, после чего удаляет "мертвые", освобождая память.
    - **Mark-Compact (Маркировка и сжатие):** Иногда после удаления "мертвых" объектов все "живые" перемещаются ближе друг к другу, освобождая большие блоки памяти.
4. **Синхронизация и паузы:** Некоторые алгоритмы GC приостанавливают выполнение всех потоков приложения (пауза "Stop-the-World"), что может привести к задержкам. Современные сборщики мусора стараются минимизировать эти паузы с помощью многопоточности и других оптимизаций.
[[Garbage Collector#^e46a15|К содержанию]]

---
## Возможные вопросы:
Виды сборщиков мусора.
Как работает Serial GC?
Как работает Parallel GC?
Как работает Concurrent Mark-Sweep GC?
Как работает Garbage-First (G1) GC?
Как работает ZGC?
Как работает Shenandoah GC?

**Виды сборщиков мусора.**
1. **Serial Garbage Collector**
    - Простой однопоточный сборщик, работающий с "Stop-the-World" паузами.
    - Идеален для небольших приложений, запускаемых на одноядерных системах, или для сред с ограниченными ресурсами.
    - Включается с параметром `-XX:+UseSerialGC`.
2. **Parallel Garbage Collector (Parallel GC)**
    - Использует многопоточность для параллельной сборки мусора, чтобы ускорить процесс.
    - Подходит для приложений, ориентированных на максимальную пропускную способность, но допускающих длительные паузы.
    - Включается с параметром `-XX:+UseParallelGC`.
3. **Concurrent Mark-Sweep (CMS) Garbage Collector**
    - Сборщик, минимизирующий "Stop-the-World" паузы, работает параллельно с приложением.
    - Используется в приложениях с высокими требованиями к задержке (low-latency), например, в веб-серверах.
    - Устарел в последних версиях Java и был заменен на G1 GC.
    - Включается с параметром `-XX:+UseConcMarkSweepGC` (до Java 14).
4. **Garbage-First (G1) Garbage Collector**
    - Современный сборщик для приложений с большими объемами памяти и требованиями к низкой задержке.
    - Разбивает кучу на отдельные регионы и выполняет сборку мусора в них по мере необходимости.
    - Пытается минимизировать "Stop-the-World" паузы и может выполнять сборку одновременно с приложением.
    - Включается с параметром `-XX:+UseG1GC` и является сборщиком по умолчанию в Java 9 и выше.
5. **Z Garbage Collector (ZGC)**
    - Экспериментальный, ультранизколатентный сборщик, предназначенный для работы с кучей очень больших объемов (до терабайтов).
    - Выполняет сборку мусора с паузами порядка миллисекунд, даже при больших объемах кучи.
    - Подходит для приложений с крайне высокими требованиями к минимальным задержкам.
    - Включается с параметром `-XX:+UseZGC` и доступен в Java 11 и выше.
6. **Shenandoah Garbage Collector**
    - Экспериментальный сборщик с низкими задержками, аналогичный ZGC.
    - Поддерживает большие объемы памяти и работает со сверхкороткими паузами, минимизируя время "Stop-the-World".
    - Применяется в сценариях с высокими требованиями к производительности.
    - Включается с параметром `-XX:+UseShenandoahGC` и доступен в Java 12 и выше.

**Как работает Serial GC?**
При использовании данного сборщика куча разбивается на четыре региона, три из которых относятся к младшему поколению (Eden, Survivor 0 и Survivor 1), а один (Tenured) — к старшему:  
![[Pasted image 20241108181037.png]]
Среднестатистический объект начинает свою жизнь в регионе Eden (переводится как Эдем, что вполне логично). Именно сюда его помещает JVM в момент создания. Но со временем может оказаться так, что места для вновь создаваемого объекта в Eden нет, в таких случаях запускается малая сборка мусора.  
Первым делом такая сборка находит и удаляет мертвые объекты из Eden. Оставшиеся живые объекты переносятся в пустой регион Survivor. Один из двух регионов Survivor всегда пустой, именно он выбирается для переноса объектов из Eden:  
![[Pasted image 20241108181100.png]]
Мы видим, что после малой сборки регион Eden полностью опорожнен и может быть использован для размещения новых объектов. Но рано или поздно наше приложение опять займет всю область Eden и JVM снова попытается провести малую сборку, на этот раз очищая Eden и частично занятый Survivor 0, после чего перенося все выжившие объекты в пустой регион Survivor 1:  
![[Pasted image 20241108181153.png]]
В следующий раз в качестве региона назначения опять будет выбран Survivor 0. Пока места в регионах Survivor достаточно, все идет хорошо:  
![[Pasted image 20241108181217.png]]
JVM постоянно следит за тем, как долго объекты перемещаются между Survivor 0 и Survivor 1, и выбирает подходящий порог для количества таких перемещений, после которого объекты перемещаются в Tenured, то есть переходят в старшее поколение. Если регион Survivor оказывается заполненным, то объекты из него также отправляются в Tenured:  
  ![[Pasted image 20241108181231.png]]
Описанный процесс малой сборки мусора достаточно прост, но причины использования регионов Survivor, причем именно двух, не всегда понятны. Я думаю, детальное объяснение причин мы оставим за рамками данной статьи (разобрали в [комментариях](https://habr.com/ru/articles/269707/#comment_8633685)), а здесь лишь отметим, что из двух основных способов работы с выжившими объектами — уплотнение и копирование — в Sun при разработке малого сборщика мусора пошли по второму пути, так как он проще в реализации и зачастую оказывается производительнее.  
В случае, когда места для новых объектов не хватает уже в Tenured, в дело вступает полная сборка мусора, работающая с объектами из обоих поколений. При этом старшее поколение не делится на подрегионы по аналогии с младшим, а представляет собой один большой кусок памяти, поэтому после удаления мертвых объектов из Tenured производится не перенос данных (переносить уже некуда), а их уплотнение, то есть размещение последовательно, без фрагментации. Такой механизм очистки называется Mark-Sweep-Compact по названию его шагов (пометить выжившие объекты, очистить память от мертвых объектов, уплотнить выжившие объекты).  
![[Pasted image 20241108181253.png]]

**Как работает Parallel GC?**

**Как работает Concurrent Mark-Sweep GC?**

**Как работает Garbage-First (G1) GC?**

**Как работает ZGC?**

**Как работает Shenandoah GC?**


[[Garbage Collector#^e46a15|К содержанию]]

---
